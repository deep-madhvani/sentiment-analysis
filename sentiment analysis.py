# -*- coding: utf-8 -*-
"""CPSC 585: Project 2: Group 12

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EXlRoRK1zux6RZoc5VEL1R8lZ9yz_7q9

# **CPSC 585 - Artificial Neural Networks**

**Group Project 2, Spring 2023**

Professor: **Kenytt Avery**

**Group 12:**
> * Aneesh Reddy Sannapu
> * Anvit Rajesh Patil
> * Bhavyom Singh Kushwaha
> * Deep Bhikhabhai Madhvani
> * Mann Gawade
> * Sean Hale

# Data Visualization
"""

import seaborn as sns

data = pd.read_csv("/content/drive/MyDrive/ann2/RateMyProfessor_Sample data.csv")

"""From the kernel density estimate, we can observe that star rating and difficulty have an inverse relation. For the professors with high star rating, the difficulty us low and professors with low rating the difficulty is high."""

sns.kdeplot(x = data["student_star"], y = data['student_difficult'],fill=True, common_norm=False)

"""Count Plot tells us that most students rate their professor 3 or above."""

sns.countplot(x= data['star_rating'])

sns.heatmap(data.corr())

"""The below graph shows us that if a student got good grades, they are more likely to rate their professor 3.5 or above"""

sns.FacetGrid(data, hue="grades", height = 5).map(sns.histplot, "star_rating").add_legend()

"""# **Approach 1: Topic Modeling**

**Overview**

*  Prepare the dataset by padding the comments and tokenizing the tokens.

* Using spaCy to eliminate commas and extract phrases with important teacher evaluation and difficulty-related words. With named entity recognition, quick access to word vectors, and extremely quick and accurate syntactic analysis, spaCy is a powerful tool to be use here.

* Building a neural network with Keras to determine whether a comment is connected to teacher evaluation or level ofÂ difficulty.

* Analyzing the model's performance using the test data set's correctness.

* We have also used the text-processing.com API which is a simple JSON over HTTP web service for text mining and natural language processing.

**Analyzing**

>We obtain accuracy of **71%** for star rating and **63%** for difficulty over the training data set.

>We used different dataset to test, over the test data set we get accuracy of **62%** for star rating and accuracy of **54%**  for difficulty

Topic modeling is useful when we try to get hidden patterns from text data, which can be beneficial in identifying important aspects of the text data.

The results is sensitive to the choice of hyperparameters, such as the number of topics to be extracted, which might hinder our accuracy.

*We consider tolerance of 1 in testing*
"""

# We have imported the necessary libraries and downloaded the "en_core_web_lg" model from spaCy
#The model en_core_web_lg is spaCy's biggest English model, measuring 788 MB.

import pandas as pd
import numpy as np
import spacy
import keras
from spacy.lang.en import STOP_WORDS
from spacy.lang.en.stop_words import STOP_WORDS as EN_STOP_WORDS
import spacy.cli
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
import os
import seaborn as sns

spacy.cli.download("en_core_web_lg")
nlp = spacy.load("en_core_web_lg")

#below code reads The Dataset from GoogleDrive

data = pd.read_csv("/content/drive/MyDrive/ann2/RateMyProfessor_Sample data.csv")
print(data.head(5))

df = data

sns.kdeplot(x = data["student_star"], y = data['student_difficult'],fill=True, common_norm=False)

embeddings_index = {}

#This cell reads in pre-trained word embeddings from a file called "glove.42B.300d.txt" and stores them in a
#dictionary called embeddings_index. The file contains a list of words and their corresponding 300-dimensional vectors
with open('/content/drive/MyDrive/ann2/glove.42B.300d.txt', encoding="utf8") as f:
    for line in f:
        values = line.split()
        word = values[0]
        coefs = np.asarray(values[1:], dtype='float32')
        embeddings_index[word] = coefs

comments_df =df

# In this function list of stopwords are used to ensure that the commonly occuring words in english are removed from the comments.
def get_teacher_rating(comment):

    stop_words = list(STOP_WORDS) + list(EN_STOP_WORDS)
    comment_tokens = [token.text for token in nlp(comment) if token.text not in stop_words]


    rating_sentences = []
    rating_keywords = ["he","she" "excellent", "good", "average", "poor", "terrible", "knowledgeable", "approachable", "helpful", "unhelpful", "responsive", "inspiring", "engaging", "boring", "clear", "confusing", "challenging", "fair", "unfair", "grading", "assessments"]
    for sent in nlp(comment).sents:
        if (any(keyword in sent.text.lower() for keyword in rating_keywords)):
            rating_sentences.append(sent.text)


    rating_summary = ""
    for sentence in rating_sentences:
        sentence_tokens = [token.text for token in nlp(sentence) if token.text not in stop_words]
        if len(set(comment_tokens).intersection(set(sentence_tokens))) > 0:
            rating_summary += sentence.strip() + " "

    return rating_summary

# Similar to the above function for difficulty, a list of stopwords are used to ensure that the commonly occuring words in english are removed from the comments.
def get_teacher_difficulty(comment):

    stop_words = list(STOP_WORDS) + list(EN_STOP_WORDS)
    comment_tokens = [token.text for token in nlp(comment) if token.text not in stop_words]


    difficulty_sentences = []
    dif_keywords = ["challenging", "easy", "hard", "tough", "demanding", "time-consuming", "confusing", "complex", "difficult", "tricky", "intimidating", "daunting", "overwhelming", "strenuous", "arduous"]
    for sent in nlp(comment).sents:
        if (any(keyword in sent.text.lower() for keyword in dif_keywords)):
            difficulty_sentences.append(sent.text)


    difficulty_summary = ""
    for sentence in difficulty_sentences:
        sentence_tokens = [token.text for token in nlp(sentence) if token.text not in stop_words]
        if len(set(comment_tokens).intersection(set(sentence_tokens))) > 0:
            difficulty_summary += sentence.strip() + " "

    return difficulty_summary

# the teacher_rating_summary and teacher_difficulty_summary columns are added to the comments_df.
comments_df['teacher_rating_summary'] = comments_df['comments'].astype(str).apply(get_teacher_rating)
comments_df['teacher_difficulty_summary'] = comments_df['comments'].astype(str).apply(get_teacher_difficulty)

#for both column star and difficulty we use lamda function , if value is greater then 2.5 then assign 1 and if not assign 0 to corresponding row.
comments_df['student_star'] = df['student_star'].apply(lambda x: 1 if x > 2.5 else 0 )
comments_df['student_difficult'] = df['student_difficult'].apply(lambda x: 1 if x > 2.5 else 0 )

# Preprocessing the Dataset by tokanizing and padding the comments
tokenizer = Tokenizer()
comments1 = comments_df['teacher_rating_summary'].astype(str).values
tokenizer.fit_on_texts(comments1)
sequences1 = tokenizer.texts_to_sequences(comments1)
max_seq_len1 = max([len(seq) for seq in sequences1])
padded_sequences1 = pad_sequences(sequences1, maxlen=max_seq_len1, padding='post')

comments = comments_df['teacher_difficulty_summary'].astype(str).values
tokenizer.fit_on_texts(comments)
sequences = tokenizer.texts_to_sequences(comments)
max_seq_len = max([len(seq) for seq in sequences])
padded_sequences = pad_sequences(sequences, maxlen=max_seq_len, padding='post')


#  network architecture using Keras
vocab_size = len(tokenizer.word_index) + 1
embedding_matrix = np.zeros((vocab_size, 300))
for word, i in tokenizer.word_index.items():
    embedding_vector = embeddings_index.get(word)
    if embedding_vector is not None:
        embedding_matrix[i] = embedding_vector

model_rating = keras.Sequential([
    keras.layers.Embedding(vocab_size, 300, weights=[embedding_matrix], input_length=128, trainable=False),
    keras.layers.LSTM(64, dropout=0.2, recurrent_dropout=0.2),
    keras.layers.Dense(1, activation='linear')
])

model_difficulty = keras.Sequential([
    keras.layers.Embedding(vocab_size, 300, weights=[embedding_matrix], input_length=73, trainable=False),
    keras.layers.LSTM(64, dropout=0.2, recurrent_dropout=0.2),
    keras.layers.Dense(1, activation='linear')
])

model_rating.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
model_difficulty.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

from keras.models import load_model

print("Model Summary for Student Star")
model1.summary()

print()
print("Model Summary for Student Difficulty")
model.summary()

model_rating.fit(padded_sequences1, np.array(comments_df['student_star']), epochs=5, batch_size=100)
model_difficulty.fit(padded_sequences, np.array(comments_df['student_difficult']), epochs=5, batch_size=100)

"""**Both the models are trainned and model_rating have achived the accuracy of 0.7161 and model_difficulty has achived an accuracy of 0.6356. We Save the models in the next step.**"""

model_rating.save('/content/drive/MyDrive/ann2/models/rating_model_topicmod.h5')
model_difficulty.save('/content/drive/MyDrive/ann2/models/diff_model_topicmod.h5')

"""**TESTING ON NEW DATA**"""

import json
import pandas as pd


with open('/content/drive/MyDrive/ann2/all_reviews.json', 'r') as f:
    data = json.load(f)

# Extract relevant columns
df = pd.DataFrame(columns=['Quality', 'Difficulty', 'Comment'])
for entry in data:
    for item in entry:
        df = df.append({
            'Quality': item['Quality'],
            'Difficulty': item['Difficulty'],
            'Comment': item['Comment']
        }, ignore_index=True)

test_data =df

test_data

import pandas as pd
import numpy as np
import pandas as pd
import tensorflow as tf
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM, Embedding, Dropout
from keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.layers import Embedding, SimpleRNN, Dense
from sklearn.model_selection import train_test_split


max_seq_len = 128
model = load_model('/content/drive/MyDrive/ann2/models/rating_model_topicmod.h5')

# Define the API endpoint
url = "http://text-processing.com/api/sentiment/"


df = test_data[0:100]


def calculate_score(comment):

    response = requests.post(url, data={'text': comment})

    sentiment_score = response.json()['probability']['pos']
    # Use TexBlob to get the sentiment polarity
    polarity = TextBlob(comment).sentiment.polarity

    comment_seq = tokenizer.texts_to_sequences([comment])
    comment_seq = pad_sequences(comment_seq, maxlen=max_seq_len, padding='post')

    score = model.predict(comment_seq)[0][0]
    score = (score*4)+1
    # Calculate the final score based on polarity and sentiment
    if polarity > .15:
        if sentiment_score < .4:
            score1 = (score + ((abs(polarity)) * 1.8) - 1)
        elif sentiment_score > .4:
            score1 = (score + ((abs(polarity)) * 1.8) +1)
    elif polarity <.15:
        if sentiment_score < .4:
            score1 = (score - ((abs(polarity)) * 1.8) - 1)
        elif sentiment_score > .4:
            score1 = (score - ((abs(polarity)) * 1.8) +1)
    if score1 > 5:
        score1 = 5
    elif score1<1:
        score1 = 1
    return np.round(score1*2)/2


df['Final Score'] = df['Comment'].apply(calculate_score)

df

df1 = np.array(df['Final Score'])
df1

df2 = np.array(df['Quality'])
df2 =  df2.astype(float)
df2

within_tolerance = np.abs(df1 - df2) <= tolerance


accuracy = np.mean(within_tolerance) * 100

print("Accuracy percentage for rating with MSE of", tolerance, "is:", accuracy, "%")

max_seq_len = 78
model = load_model('/content/drive/MyDrive/ann2/models/diff_model_topicmod.h5')

# Define the API endpoint
url = "http://text-processing.com/api/sentiment/"


df = test_data[0:100]


def calculate_score(comment):

    response = requests.post(url, data={'text': comment})

    sentiment_score = response.json()['probability']['pos']
    # Use TexBlob to get the sentiment polarity
    polarity = TextBlob(comment).sentiment.polarity

    comment_seq = tokenizer.texts_to_sequences([comment])
    comment_seq = pad_sequences(comment_seq, maxlen=max_seq_len, padding='post')

    score = model.predict(comment_seq)[0][0]
    score = (score*4)+1
    # Calculate the final score based on polarity and sentiment
    if polarity > .15:
        if sentiment_score < .4:
            score1 = (score + ((abs(polarity)) * 1.8) - 1)
        elif sentiment_score > .4:
            score1 = (score + ((abs(polarity)) * 1.8) +1)
    elif polarity <.15:
        if sentiment_score < .4:
            score1 = (score - ((abs(polarity)) * 1.8) - 1)
        elif sentiment_score > .4:
            score1 = (score - ((abs(polarity)) * 1.8) +1)
    if score1 > 5:
        score1 = 5
    elif score1<1:
        score1 = 1
    return np.round(score1*2)/2


df['Final Score diff'] = df['Comment'].apply(calculate_score)

df1 = np.array(df['Final Score diff'])
df2 = np.array(df['Difficulty'])
df2 =  df2.astype(float)

within_tolerance = np.abs(df1 - df2) <= tolerance


accuracy = np.mean(within_tolerance) * 100

print("Accuracy percentage for dif with MSE of", tolerance, "is:", accuracy, "%")

"""# **Appraoch 2: Sentiment Intensity Analysis, Version 1**

**Overview**

A model for text sentiment analysis called VADER (Valence Aware Dictionary for Sentiment Reasoning) is sensitive to both the polarity (positive/negative) and intensity (strong) of emotion. It may be used right away on unlabeled text data and is included in the NLTK package.

**Analyzing**

Star Rating
>**Training data Mean Squared Error** : **1.16**

> **Test data Accuracy** : **63%**.

Difficulty Rating
>**Training data Mean Squared Error**: **1.48**

>**Test data Accuracy** : **65%**.

This model considers both polarity and intensity of emotions, which provides more nuanced results.

We haven't perform any hyperparameter tuning for this model

*We consider tolerance of 1 in testing*
"""

## Adding necessary imports
import pandas as pd
import nltk
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, SimpleRNN

## Loading dataset
data = pd.read_csv("/content/drive/MyDrive/ann2/RateMyProfessor_Sample data.csv")
## Displaying top 5 rows
data.head(5)

df = data

"""We have used Sentiment Intensity Analyzer to get different polarity scores(such as polarity, positive score, negative score, neutral score) for the comments from our dataset."""

## Downloading VADER Lexicon and initailizing Sentiment Intensity Analyzer
nltk.download('vader_lexicon')
sia = SentimentIntensityAnalyzer()

def get_sentiment_scores(comment):
    sentiment_scores = sia.polarity_scores(comment)
    return sentiment_scores['compound'], sentiment_scores['pos'], sentiment_scores['neg'], sentiment_scores['neu']

df['polarity'], df['pos_score'], df['neg_score'], df['neu_score'] = zip(*df['comments'].astype(str).apply(get_sentiment_scores))

"""Rearranging the column to create a single dataframe and then splitting them into X and Y values, also dropping NA values"""

X = np.array(df[['polarity', 'pos_score', 'neg_score', 'neu_score']])
y = np.array(df['student_star'])

df[['polarity', 'pos_score', 'neg_score', 'neu_score','student_star']]

k = df[['polarity', 'pos_score', 'neg_score', 'neu_score','student_star']]

k = k.dropna()
X = k[['polarity', 'pos_score', 'neg_score', 'neu_score']]
y = k['student_star']

"""> Here, we are scaling the values and defining the architechture of our model. We have used a Sequential model with two LSTM layers and a Dense layer.

> The first LSTM layer has 64 units and ReLU as the activation function. The second LSTM is similar with 32 units and ReLU as the activation function. We have added a Dropout layer as well in between the two LSTM layers. We also have a Dense layer with linear activation function.

>On evaluating the model, we are getting a **Mean Squared Error** as **1.1682180166244507**
"""

scaler = StandardScaler()
X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# architecture of the LSTM
model = Sequential()
model.add(LSTM(units=64, input_shape=(X_train.shape[1], 1), activation='relu', return_sequences=True))
model.add(Dropout(0.2))
model.add(LSTM(units=32, activation='relu'))
model.add(Dense(units=1, activation='linear'))

model.compile(optimizer='adam', loss='mean_squared_error')


model.fit(X_train.reshape((X_train.shape[0], X_train.shape[1], 1)), y_train, epochs=10, batch_size=32)


mse = model.evaluate(X_test.reshape((X_test.shape[0], X_test.shape[1], 1)), y_test)
print("Mean Squared Error:", mse)

model.summary()

model.save('/content/drive/MyDrive/ann2/models/senti_rating.h5')

"""Now, we are trying to predict and check the accuracy of our model for **Student Star Rating** on the all_reviews.json.

 > Testing MSE : 1.1682180166244507

 > Testing accuracy : 67%

Here, we are loading the testing dataset and extracting columns like Quality, Difficulty and Comment.
"""

import json
import pandas as pd


with open('/content/drive/MyDrive/ann2/all_reviews.json', 'r') as f:
    data = json.load(f)

# Extract relevant columns
df = pd.DataFrame(columns=['Quality', 'Difficulty', 'Comment'])
for entry in data:
    for item in entry:
        df = df.append({
            'Quality': item['Quality'],
            'Difficulty': item['Difficulty'],
            'Comment': item['Comment']
        }, ignore_index=True)

test_data = df

test_data

df = test_data[0:100]

df

"""Here, we have defined the predict function that uses polarities and saved model."""

import numpy as np
import pandas as pd
import requests
from keras.models import load_model

def predict_the(df):
    max_seq_len = 78
    model = load_model('/content/drive/MyDrive/ann2/models/senti_rating.h5')

    scores = []
    for comment in df['Comment']:


        #  sentiment scores
        sentiment_scores = sia.polarity_scores(comment)
        polarity_vader = sentiment_scores['compound']
        pos_score = sentiment_scores['pos']
        neg_score = sentiment_scores['neg']
        neu_score = sentiment_scores['neu']

        # Prepare the comment data for input to the model
        new_comment = np.array([polarity, pos_score, neg_score, neu_score]).reshape((1, 4, 1))

        # Make the prediction using the model
        prediction = model.predict(new_comment)
        score = prediction[0][0]



        # Round the score to the nearest half point
        k = (np.round(score * 2) / 2)
        scores.append(k)

    # Add the predicted scores as a new column in the dataframe
    df['predicted_score'] = scores

    return df

df = predict_the(df)

df1 = np.array(df['predicted_score'])
df2 = np.array(df['Quality'])
df2 =  df2.astype(float)


within_tolerance = np.abs(df1 - df2) <= tolerance
accuracy = np.mean(within_tolerance) * 100
print("Accuracy percentage for star rating with MSE of", tolerance, "is:", accuracy, "%")

"""Now, we will apply similar approach for Student Difficulty Rating"""

k = df[['polarity', 'pos_score', 'neg_score', 'neu_score','student_difficult']]

k = k.dropna()
X = k[['polarity', 'pos_score', 'neg_score', 'neu_score']]
y = k['student_difficult']

"""We are performing the following steps:
> Scaling input X

> Splitting Dataset

> Training Model

> Evaluating model for MSE on training data

**For Difficulty Rating, MSE** : **1.50236177444458**
"""

scaler = StandardScaler()
X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# architecture of the LSTM
model = Sequential()
model.add(LSTM(units=64, input_shape=(X_train.shape[1], 1), activation='relu', return_sequences=True))
model.add(Dropout(0.2))
model.add(LSTM(units=32, activation='relu'))
model.add(Dense(units=1, activation='linear'))

model.compile(optimizer='adam', loss='mean_squared_error')


model.fit(X_train.reshape((X_train.shape[0], X_train.shape[1], 1)), y_train, epochs=10, batch_size=32)


mse = model.evaluate(X_test.reshape((X_test.shape[0], X_test.shape[1], 1)), y_test)
print("Mean Squared Error:", mse)

model.summary()

## Saving the difficulty model
model.save('/content/drive/MyDrive/ann2/models/senti_diff.h5')

"""Now we are predicting and evaluating the accuracy on test data.
> To do that, we have loaded the test data and extracted relevant columns such as Quality, Difficulty and Comments.
"""

import json
import pandas as pd


with open('/content/drive/MyDrive/ann2/all_reviews.json', 'r') as f:
    data = json.load(f)

# Extract relevant columns
df = pd.DataFrame(columns=['Quality', 'Difficulty', 'Comment'])
for entry in data:
    for item in entry:
        df = df.append({
            'Quality': item['Quality'],
            'Difficulty': item['Difficulty'],
            'Comment': item['Comment']
        }, ignore_index=True)

test_data = df

df = test_data[0:100]

df

"""> Here we have defined a predict function that used model and polarities to predict.

Difficulty Rating
> **Testing Accuracy** : **65%**
"""

import numpy as np
import pandas as pd
import requests

from keras.models import load_model

def predict_the_dif(df):
    max_seq_len = 78
    model = load_model('/content/drive/MyDrive/ann2/models/senti_diff.h5')

    scores = []
    for comment in df['Comment']:


        # Use VADER to get the sentiment scores
        sentiment_scores = sia.polarity_scores(comment)
        polarity_vader = sentiment_scores['compound']
        pos_score = sentiment_scores['pos']
        neg_score = sentiment_scores['neg']
        neu_score = sentiment_scores['neu']

        # Prepare the comment data for input to the model
        new_comment = np.array([polarity_vader, pos_score, neg_score, neu_score]).reshape((1, 4, 1))

        # Make the prediction using the model
        prediction = model.predict(new_comment)
        score = prediction[0][0]

        # Apply rules to adjust the score based on sentiment and polarity

        if score > 5:
            score = 5
        elif score < 1:
            score = 1


        # Round the score to the nearest half point
        k = (np.round(score * 2) / 2)
        scores.append(k)

    # Add the predicted scores as a new column in the dataframe
    df['predicted_score'] = scores

    return df

df = predict_the_dif(df)

df

df1 = np.array(df['predicted_score'])
df2 = np.array(df['Difficulty'])
df2 =  df2.astype(float)

within_tolerance = np.abs(df1 - df2) <= tolerance
accuracy = np.mean(within_tolerance) * 100
print("Accuracy percentage for star difficulty is:", accuracy, "%")

"""# **Approach 3: Sentiment Intensity Analysis, Version 2**

**Overview**

In this version, we are doing test cleaning aggressively to evaluate if we get a better accuracy.
> We are removing punctuation and stopwords in addition to dropping NA fields.

> Code is similar to the last approach

> There is a significant in accuracy for Difficulty Rating and Star Rating accuracy also improved. We can see the impact of cleaning data. The loss increased, slightly.

**Analysis**

Star Rating
> Traning MSE : 1.299601435661316

> Testing MSE : 1.2041118144989014

> Testing Accuracy : 65%

Difficulty Rating
> Traning MSE : 1.5125211477279663

> Testing MSE : 1.5

> Testing Accuracy : 73%



*We consider tolerance of 1 in testing*
"""

data = pd.read_csv("/content/drive/MyDrive/ann2/RateMyProfessor_Sample data.csv")
data.head(5)

df = data

"""Removing punctuations from dataframe"""

df['comments'] = df['comments'].str.lower()
import string
import re

def remove_punctuation(text):
    return text.translate(str.maketrans('', '', string.punctuation))

def remove_punctuation_extra(text):
    text = re.sub('[â-]', ' ', text)
    text = re.sub('[ââ]', '', text)
    return text

df['comments'] = df['comments'].astype(str).apply(remove_punctuation_extra)
df['comments'] = df['comments'].astype(str).apply(remove_punctuation)

"""Downloading and Removing stopwords from dataframe"""

import nltk
nltk.download('stopwords')
def remove_stopwords(text):
    stopwords = nltk.corpus.stopwords.words('english')
    removed = [i for i in text.split() if i not in stopwords]
    return removed

df['comments'] = df['comments'].apply(remove_stopwords)
df['comments'] = df['comments'].str.join(' ')

"""In this step, we have performed the following for **Star Rating**,
>using VADER lexicon and Sentiment Intensity Analyser to get polarity scores

>dropping NA fields, and arranging the fields to get X and Y datasets.

>Splitting the data, creating model and training the model

>Evaluating the model for Mean Squared Error and finally saving the model

**Mean Squared Error : 1.299601435661316**
"""

nltk.download('vader_lexicon')
sia = SentimentIntensityAnalyzer()

def get_sentiment_scores(comment):
    sentiment_scores = sia.polarity_scores(comment)
    return sentiment_scores['compound'], sentiment_scores['pos'], sentiment_scores['neg'], sentiment_scores['neu']


df['polarity'], df['pos_score'], df['neg_score'], df['neu_score'] = zip(*df['comments'].astype(str).apply(get_sentiment_scores))




X = np.array(df[['polarity', 'pos_score', 'neg_score', 'neu_score']])
y = np.array(df['student_star'])


df[['polarity', 'pos_score', 'neg_score', 'neu_score','student_star']]


k = df[['polarity', 'pos_score', 'neg_score', 'neu_score','student_star']]


k = k.dropna()
X = k[['polarity', 'pos_score', 'neg_score', 'neu_score']]
y = k['student_star']


scaler = StandardScaler()
X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# architecture of the LSTM
model = Sequential()
model.add(LSTM(units=64, input_shape=(X_train.shape[1], 1), activation='relu', return_sequences=True))
model.add(Dropout(0.2))
model.add(LSTM(units=32, activation='relu'))
model.add(Dense(units=1, activation='linear'))

model.compile(optimizer='adam', loss='mean_squared_error')


model.fit(X_train.reshape((X_train.shape[0], X_train.shape[1], 1)), y_train, epochs=10, batch_size=32)


mse = model.evaluate(X_test.reshape((X_test.shape[0], X_test.shape[1], 1)), y_test)
print("Mean Squared Error:", mse)


model.save('/content/drive/MyDrive/ann2/models/senti_rating_filter.h5')

model.summary()

"""In this step, we have performed the following for **Difficulty Rating**,
>using VADER lexicon and Sentiment Intensity Analyser to get polarity scores

>dropping NA fields, and arranging the fields to get X and Y datasets.

>Splitting the data, creating model and training the model

>Evaluating the model for Mean Squared Error and finally saving the model

**Mean Squared Error : 1.5125211477279663**
"""

nltk.download('vader_lexicon')
sia = SentimentIntensityAnalyzer()

def get_sentiment_scores(comment):
    sentiment_scores = sia.polarity_scores(comment)
    return sentiment_scores['compound'], sentiment_scores['pos'], sentiment_scores['neg'], sentiment_scores['neu']


df['polarity'], df['pos_score'], df['neg_score'], df['neu_score'] = zip(*df['comments'].astype(str).apply(get_sentiment_scores))



k = df[['polarity', 'pos_score', 'neg_score', 'neu_score','student_difficult']]

k = k.dropna()
X = k[['polarity', 'pos_score', 'neg_score', 'neu_score']]
y = k['student_difficult']

scaler = StandardScaler()
X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# architecture of the LSTM
model = Sequential()
model.add(LSTM(units=64, input_shape=(X_train.shape[1], 1), activation='relu', return_sequences=True))
model.add(Dropout(0.2))
model.add(LSTM(units=32, activation='relu'))
model.add(Dense(units=1, activation='linear'))

model.compile(optimizer='adam', loss='mean_squared_error')


model.fit(X_train.reshape((X_train.shape[0], X_train.shape[1], 1)), y_train, epochs=10, batch_size=32)


mse = model.evaluate(X_test.reshape((X_test.shape[0], X_test.shape[1], 1)), y_test)
print("Mean Squared Error:", mse)

model.save('/content/drive/MyDrive/ann2/models/senti_diff_filter.h5')

model.summary()

"""In this step, we are performing the following for **Star Rating**,

> Loading the testing dataset and extracting the useful columns such as Quality, Difficulty and Comment

>Creating a prediction function that uses prolarity scores and saved model for prediction and accuracy.

**Star Rating :**

>MSE : 1.2041118144989014

>Accuracy : 65%
"""

import json
import pandas as pd


with open('/content/drive/MyDrive/ann2/all_reviews.json', 'r') as f:
    data = json.load(f)

# Extract relevant columns
df = pd.DataFrame(columns=['Quality', 'Difficulty', 'Comment'])
for entry in data:
    for item in entry:
        df = df.append({
            'Quality': item['Quality'],
            'Difficulty': item['Difficulty'],
            'Comment': item['Comment']
        }, ignore_index=True)

test_data = df


df = test_data[0:100]


import numpy as np

import requests
from keras.models import load_model

def predict_the(df):
    max_seq_len = 78
    model = load_model('/content/drive/MyDrive/ann2/models/senti_rating_filter.h5')

    scores = []
    for comment in df['Comment']:


        #  sentiment scores
        sentiment_scores = sia.polarity_scores(comment)
        polarity_vader = sentiment_scores['compound']
        pos_score = sentiment_scores['pos']
        neg_score = sentiment_scores['neg']
        neu_score = sentiment_scores['neu']

        # Prepare the comment data for input to the model
        new_comment = np.array([polarity, pos_score, neg_score, neu_score]).reshape((1, 4, 1))

        # Make the prediction using the model
        prediction = model.predict(new_comment)
        score = prediction[0][0]



        # Round the score to the nearest half point
        k = (np.round(score * 2) / 2)
        scores.append(k)

    # Add the predicted scores as a new column in the dataframe
    df['predicted_score'] = scores

    return df


df = predict_the(df)


df1 = np.array(df['predicted_score'])
df2 = np.array(df['Quality'])
df2 =  df2.astype(float)



within_tolerance = np.abs(df1 - df2) <= tolerance
accuracy = np.mean(within_tolerance) * 100

print("Accuracy percentage for star rating with MSE of", "is:", accuracy, "%")

"""In this step, we are performing the following for **Difficulty Rating**,

> Loading the testing dataset and extracting the useful columns such as Quality, Difficulty and Comment

>Creating a prediction function that uses prolarity scores and saved model for prediction and accuracy.

**Difficulty Rating :**

>MSE : 1.5

>Accuracy : 73%
"""

import json
import pandas as pd


with open('/content/drive/MyDrive/ann2/all_reviews.json', 'r') as f:
    data = json.load(f)

# Extract relevant columns
df = pd.DataFrame(columns=['Quality', 'Difficulty', 'Comment'])
for entry in data:
    for item in entry:
        df = df.append({
            'Quality': item['Quality'],
            'Difficulty': item['Difficulty'],
            'Comment': item['Comment']
        }, ignore_index=True)

test_data = df


df = test_data[0:100]


import numpy as np
import pandas as pd
import requests
from keras.models import load_model

def predict_the(df):
    max_seq_len = 78
    model = load_model('/content/drive/MyDrive/ann2/models/senti_diff_filter.h5')

    scores = []
    for comment in df['Comment']:


        #  sentiment scores
        sentiment_scores = sia.polarity_scores(comment)
        polarity_vader = sentiment_scores['compound']
        pos_score = sentiment_scores['pos']
        neg_score = sentiment_scores['neg']
        neu_score = sentiment_scores['neu']

        # Prepare the comment data for input to the model
        new_comment = np.array([polarity, pos_score, neg_score, neu_score]).reshape((1, 4, 1))

        # Make the prediction using the model
        prediction = model.predict(new_comment)
        score = prediction[0][0]



        # Round the score to the nearest half point
        k = (np.round(score * 2) / 2)
        scores.append(k)

    # Add the predicted scores as a new column in the dataframe
    df['predicted_score'] = scores

    return df


df = predict_the(df)


df1 = np.array(df['predicted_score'])
df2 = np.array(df['Difficulty'])
df2 =  df2.astype(float)


within_tolerance = np.abs(df1 - df2) <= tolerance
accuracy = np.mean(within_tolerance) * 100

print("Accuracy percentage for star rating with MSE of ", tolerance, "is:", accuracy, "%")

"""# **Approach 4: Rescaling and word embedding**

**Overview**

In this approach, we are using Glove, the pre-trained word embedding.
We have also scaled the star and difficulty from 0 to 1. After that we gave this data to an RNN model.

Model architecture as follows,

Embedding layer - Dropout layer - 1-D convolution layer - 1-D Max Pooling - Bidirectional LSTM - Dense Layer

We have also used the text-processing.com API which is a simple JSON over HTTP web service for text mining and natural language processing.

 **Analysis**

 Star Rating
 > Testing Accuracy : 51%

 Difficulty Rating
 > Testing Accuracy : 51%


 *We consider tolerance of 1 in testing*
"""

## Loading dataset
import pandas as pd
data = pd.read_csv("/content/drive/MyDrive/ann2/RateMyProfessor_Sample data.csv")

# importing the necessary libraries

from keras.models import load_model
import requests
from textblob import TextBlob
import numpy as np
import pandas as pd
import tensorflow as tf
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM, Embedding, Dropout
from keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.layers import Embedding, SimpleRNN, Dense
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, Dropout, Conv1D, MaxPool1D, Bidirectional, LSTM, Dense

df =data

comments = df['comments'].astype(str).values

# The below two codes assigns the values of the "student_star" and "student_difficult" column to a variables in Series containing binary values (0 or 1)
# indicating whether the student gave the professor a rating above or below 2.5 (out of 5)

labels = df['student_star'].apply(lambda x: 1 if x > 2.5 else 0 )
labels2 = df['student_difficult'].apply(lambda x: 1 if x > 2.5 else 0 )

embeddings_index = {}

# This cell reads in pre-trained word embeddings from a file called "glove.42B.300d.txt" and stores them in a dictionary called embeddings_index.
# The file contains a list of words and their corresponding 300-dimensional vectors

with open('/content/drive/MyDrive/ann2/glove.42B.300d.txt', encoding="utf8") as f:
    for line in f:
        values = line.split()
        word = values[0]
        coefs = np.asarray(values[1:], dtype='float32')
        embeddings_index[word] = coefs

"""Tokenizing and Padding the input"""

# Preprocessing the Data for training

embedding_dim =300
result = pd.concat([labels, labels2], axis=1)
tokenizer = Tokenizer()
tokenizer.fit_on_texts(comments)
sequences = tokenizer.texts_to_sequences(comments)
max_seq_len = max([len(seq) for seq in sequences])
padded_sequences = pad_sequences(sequences, maxlen=max_seq_len, padding='post')

vocab_size = len(tokenizer.word_index) + 1
embedding_matrix = np.zeros((vocab_size, embedding_dim))
for word, i in tokenizer.word_index.items():
    embedding_vector = embeddings_index.get(word)
    if embedding_vector is not None:
        embedding_matrix[i] = embedding_vector

"""For Star Rating, we got,

>Training Loss : 0.4313

>Training Accuracy : 83.72%

>Validatoin Loss : 0.6201

> Validation accuracy : 84.2%

"""

model_glove = Sequential()
model_glove.add(Embedding(len(tokenizer.word_index) + 1, 300, input_length=145, weights=[embedding_matrix], trainable=False))
model_glove.add(Dropout(0.2))
model_glove.add(Conv1D(64, 5, activation='relu'))
model_glove.add(MaxPool1D(pool_size=4))
model_glove.add(Bidirectional(LSTM(100)))
model_glove.add(Dense(2, activation='linear'))


model_glove.compile(loss='binary_crossentropy', optimizer='RMSprop', metrics=['accuracy'])


model_glove.fit(padded_sequences, np.array(result), validation_split=0.2, epochs=8, batch_size=32)

model_glove.summary()

model_glove.save('/content/drive/MyDrive/ann2/models/rescaling(both).h5')

model = load_model('/content/drive/MyDrive/ann2/models/rescaling(both).h5')

"""Created a function to calcualte final scores"""

import pandas as pd
import numpy as np
import pandas as pd
import tensorflow as tf
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM, Embedding, Dropout
from keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.layers import Embedding, SimpleRNN, Dense
from sklearn.model_selection import train_test_split


max_seq_len = 145


# Define the API endpoint
url = "http://text-processing.com/api/sentiment/"


df = test_data[0:100]


def calculate_score(comment):

    response = requests.post(url, data={'text': comment})

    sentiment_score = response.json()['probability']['pos']
    # Use TexBlob to get the sentiment polarity for comment as it process textual data.
    polarity = TextBlob(comment).sentiment.polarity

    comment_seq = tokenizer.texts_to_sequences([comment])
    comment_seq = pad_sequences(comment_seq, maxlen=max_seq_len, padding='post')

    score = model.predict(comment_seq)[0][0]
    score = (score*4)+1

    if score > 5:
        score = 5
    elif score<1:
        score = 1
    return np.round(score*2)/2


df['Final Score'] = df['Comment'].apply(calculate_score)

df

"""**Testing Accuracy** for Star Rating : **51%**"""

df1 = np.array(df['Final Score'])
df2 = np.array(df['Quality'])
df2 =  df2.astype(float)

within_tolerance = np.abs(df1 - df2) <= tolerance
accuracy = np.mean(within_tolerance) * 100

print("Accuracy percentage for star rating is:", accuracy, "%")

"""Now, performing the same process for Difficulty Rating.

**Testing Accuracy** for Difficulty Rating : **51%**
"""

import pandas as pd
import numpy as np
import pandas as pd
import tensorflow as tf
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM, Embedding, Dropout
from keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.layers import Embedding, SimpleRNN, Dense
from sklearn.model_selection import train_test_split


max_seq_len = 145


# Define the API endpoint
url = "http://text-processing.com/api/sentiment/"


df = test_data[0:100]


def calculate_score(comment):

    response = requests.post(url, data={'text': comment})

    sentiment_score = response.json()['probability']['pos']
    # Use TexBlob to get the sentiment polarity for comment as it use for processing textual data.
    polarity = TextBlob(comment).sentiment.polarity

    comment_seq = tokenizer.texts_to_sequences([comment])
    comment_seq = pad_sequences(comment_seq, maxlen=max_seq_len, padding='post')

    score = model.predict(comment_seq)[0][1]
    score = (score*4)+1

    if score > 5:
        score = 5
    elif score<1:
        score = 1
    return np.round(score*2)/2


df['Final Score'] = df['Comment'].apply(calculate_score)

within_tolerance = np.abs(df1 - df2) <= tolerance
accuracy = np.mean(within_tolerance) * 100

print("Accuracy percentage for  diffculty of is:", accuracy, "%")

"""# **Playing with models**

We came across a lib called text blob, so we thougth we can use it to tackel the problem of tolarance and the mse in the models.

We came up with some semi-hard coded code, which with the help of TEXTblob add/sub on out model's prediction to give more accurate real life predicitons.
"""

from keras.models import load_model
import requests
from textblob import TextBlob

def predict_the(df):
    max_seq_len = 78
    model = load_model('/content/drive/MyDrive/ann2/models/senti_diff_filter.h5')

    scores = []
    for comment in df['Comment']:



        url = "http://text-processing.com/api/sentiment/"
        text = comment

        response = requests.post(url, data={'text': text})

        sentiment_score = response.json()['probability']['pos']

        polarity = TextBlob(text).sentiment.polarity
        sentiment_scores = sia.polarity_scores(comment)

        polarity_vader = sentiment_scores['compound']
        pos_score = sentiment_scores['pos']
        neg_score = sentiment_scores['neg']
        neu_score = sentiment_scores['neu']


        new_comment = np.array([polarity, pos_score, neg_score, neu_score]).reshape((1, 4, 1))


        prediction = model.predict(new_comment)
        score = prediction[0][0]


        if polarity > .15:
          if sentiment_score < .6:
            score1 = (score + ((abs(polarity)) * 1.8) - 1)
          elif sentiment_score > .6:
            score1 = (score + ((abs(polarity)) * 1.8) +1)
        elif polarity <.15:
          if sentiment_score < .6:
            score1 = (score - ((abs(polarity)) * 1.8) - 1)
          elif sentiment_score > .6:
            score1 = (score - ((abs(polarity)) * 1.8) +1)



        k = (np.round(score1 * 2) / 2)
        scores.append(k)


    df['predicted_score'] = scores

    return df

pre = str(input())
print(pre)
predcit_the(pre)

"""# Exploring Results

![image.png](data:image/png;base64,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)

The dataset we used for this project is provided by the professor.
We have used the large dataset for training and small dataset for testing.


**What do we conclude ?**

> We have tried many approach and in almost all of them we got MSE of around 1.

>Sentiment Intensity Analysis V1 is a good approach but the V2 wins the race with text cleaning.

>Sentiment Intensity Analysis Version 2 performs the best with star rating of 65% and difficulty rating of 73%.

> Although we got validation accuracy of more that 84% in Approach 4, the testing accuracy is 51%. So, it seems this model is overfitted.

# Future Scope

**Approaches**


>Compare similarity based on a predetermined dataframe containing a collection of comments which are refined to achieve a maximum attaniable upper and lower bound for ratings and score.

for now we avoided this method as it was extremely demanding in terms of computational power due to its nature. we will work on finding an alternative to make it efficient. down is the code we tried :


![image.png](data:image/png;base64,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)

>Using GloVe along with embeddings trained on the student comments datasets. GloVe can capture general language patterns, while the other embeddings can capture patterns specific to the comments posted by the students.

>We read about ensemble learning which involves using the combination of predictions given by multiple models to use performance. Using this we can combine the models used by us to get a even more accurate prediction.

>WE could experiment with GRU layers as well, for now we decided to stick with LSTM since we achieved a satisfactory accuracy.
"""